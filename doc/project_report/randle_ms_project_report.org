#+LATEX_CLASS: article
#+LaTeX_HEADER: \usepackage[a4paper, total={7in, 10in}]{geometry}
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usepackage[backend=biber, style=numeric]{biblatex}
#+LaTeX_HEADER: \addbibresource{randle_ms_project_report.bib}
#+LaTeX_HEADER: \usepackage{xcolor}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{caption}
#+LaTeX_HEADER: \usepackage[parfill]{parskip}
#+LaTeX_HEADER: \captionsetup[figure]{font=footnotesize,labelfont={bf,footnotesize}}
#+LaTeX_HEADER: \usepackage{xcolor}
#+LaTeX_HEADER: \hypersetup{colorlinks, citecolor={blue!50!black}, linkcolor={blue!35!black}, urlcolor={blue!80!black}}
#+LaTeX_HEADER: \usepackage[section]{placeins}
* Abstract

* Introduction
** Background
UAF purchased the Clearpath Jackal and Husky as assets to aid in mining emergency operations. Pogo Mine expressed interest in 
unmanned exploration and mapping facilities and Clearpath provided these platforms as turn key solutions. Several graduate students worked alongside ACUASI to further develop the platforms for UAF specific use, and to integrate UAS (unmanned ariel systems).

The Jackal and Husky provided many untapped capabilities largely due to inconvenient user interface and out-of-date software. The platforms utilize Robot Operating System (ROS) for communication and control. ROS versions are linked to specific versions of linux distributions - this is problematic and becomes more problematic as time goes by; a computer with with that specific linux distribution must be on hand to utilize ROS visualization and command capabilities (outside of using the hard-linked driving controller). Without these features, the Clearpath robots are of little value; they cannot be driven out of visual range and their included sensors are unusable.

The platforms also include base station tripod WiFi extenders and long range WiFi antennas mounted on the robots in order to provide extended WiFi network range. In the original configuration, the clearpath robots combine with the base stations to create an adhoc WiFi network. The robots and base stations make use of Ubiquity Bullet M2 extended range routers; the firmware on several of these routers had been overwritten by OpenWRT firmware rendering them useless, and the remaining routers were configured incorrectly. Also The base station extenders were missing batteries and no longer operational.

Finally, the Husky was no longer operational. The included controller no longer worked, and both clearpath robots are out of warranty.

** Project Scope
Restore clearpath platforms to a working state. Upgrade the Jackal/Husky with the latest Clearpath linux distributions and ROS packages. Restore the base stations and setup/configure the Bullet M2 routers, along with the Jackal/Husky network cards using linux netplan. Document the process of restore, setup, and configuration.

Create a web app to provide visualization and control of the Jackal/Husky, with a user interface tuned for both smart phone and desktop through a web browser. Provide different end points for full control/visualization and visualization only to allow participants to view data in read only fashion - make endpoints available to anyone
connected to the Clearpath WiFi network. Allow driving the Husky/Jackal through the control endpoint without disabling control through the wireless controller. Show a two-dimensional map with the robot and obstacles localized on the map, and provide an interface for setting autonomous navigation goals. Provide a way to reset the map without requiring robot restart.

** Related Works
There are several web and smart phone apps which provide ROS interfaces, allowing remote robot visualization and control.
Foxglove
ROSControlCenter
ROSweb
ROSboard

* System Overview

Each Clearpath robot is configured to connect or establish a Wifi hostspt with SSID "clearpath". When the base stations are powered up, they connect and extend the clearpath network

* Robot Operating System (ROS)
From the front page of ros.org, ROS is "a set of software libraries and tools that help you build robot applications". There are tutorials and explanations on how every part of ROS works available here \autocite{rosmain}, but here we summarize the parts of ROS utilized in this project.

Just like an operating system provides a standard platform/environment for applications to run, ROS provides a standard platform/environment for robot applications. All ROS tools run on top of a linux distribution, and are invoked with CLI (command line interface) just like native GNU tools (such as a C compiler, or grep). That begs the question - why not just use linux executables? That is basically what ROS is - except that it standardizes and abstracts inter-process and inter-machine communication. It does this mainly through nodes, topics, and messages.

** Setup
If using a compatible linux distrobution (currently Ubuntu 20.04 is the latest supported version) ROS can be installed using apt package manager \autocite{rosinstall}. ROS Noetic was installed on the development machine using:
#+begin_src bash
  $ sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/ros-latest.list'
  $ sudo apt install curl
  $ curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -
  $ sudo apt update
#+end_src

Once installed, a bash setup script located at /opt/ros/kinetic/setup.bash must be sourced in order for ROS tools to be available on the command line. This is a pattern that ROS uses repeatedly; set environment variables and system values by sourcing bash scripts. This allows ROS to alter system settings and provide a convenient shell interface without invading or changing the system - the settings are dropped once the shell is terminated.

In order to fully utilize ROS and build packages, some dependencies are needed. The following was used to install these dependencies on the development machine:

#+begin_src bash
  $ sudo apt install python3 python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential
  $ sudo rosdep init
  $ rosdep update
#+end_src

An ROS system can include multiple machines, but exactly one of the machines must be designated as the ROS Master (without complicated multi-master setup). Most ROS utilities provide command line arguements to specify which machine is the master, but specifying it this way is tedious and error prone. Since an ROS system includes several executables, all of which need to know who is designated master, the environment variable ROS_MASTER_URI can be set to specify the master globablly. The uri is in the format http://HOSTNAME:PORT where hostname can be either the machine name or IP address and the port can be any available open port of choice - but the docs suggest a default of 11311. ROS_MASTER_URI defaults to http://localhost:11311, so leaving it unset sets the ROS master to self.

An ROS system is started by running roscore in a terminal (after sourcing the setup script) on the designated master machine. Since ROS_MASTER_URI defaults to localhost, it can be left as default for the master. All other machines must set ROS_MASTER_URI in the terminal to the machine running roscore before invoking any ROS commands - leaving it as localhost in this case will fail with "Unable to communicate with master" as roscore has not been run on the machine. If roscore is started on multiple machines (all leaving ROS_MASTER_URI as localhost), then each machine would be running its own ROS system and ROS executables would be unable to communicate with eachother.

The Jackal and Husky run separate ROS systems - on startup they both run roscore with ROS_MASTER_URI pointing to localhost on port 11311. It is theoretically possible to use the same ROS system for both robots, but would be difficult and provide little benefit (this would be called a multi-master setup). The command roscore starts an ROS master daemon, a parameter server, and a node (a process) called rosout for logging. The ROS master daemon is responsible for connecting ROS nodes (processes) to eachother on request. Once the connection is made - nodes engage in peer to peer communication. The parameter server provides a server for nodes to register static and dynamic parameters, and the rosout node provides logging.

To setup the development machine to communicate with either the Jackal or the Husky easily, we add some lines to ~/.bashrc which is sourced on terminal startup. For convenience, we also source the ROS setup script.
#+begin_src bash
  source /opt/ros/noetic/setup.bash
  export ROS_MASTER_URI=http://cpr-uaf01:11311
  #export ROS_MASTER_URI=http://cpr-uaf02-husky:11311
#+end_src
To choose which machine just comment out the appropriate line - commenting both will set the master to self (this is used for simulation as we will discuss later). Every terminal will now have ROS commands available.

** Nodes, Packages, and Launch Files
A node is a process which is started by running an executable file on disk (or forked from another process) just like any other system process. In order for an executable to qualify as a node, when its built it must link with the ROS library and register itself (with ROS master process) on startup. ROS nodes can be built using c++ or python; if using c++ the node must link with roscpp and if using python it must link with rospy. Once a node is installed (either through apt or by building from source) it can be started in a terminal by using "rosrun node_name".

The easist way to create a ROS node is by creating a package and placing the node source in the created package. Packages are the basic "project" unit in ROS - the most simple package would be a folder containing a file named package.xml and CMakeLists.txt. The xml file specifies package dependencies, name, author, and other such meta information. The CMakeLists.txt file is a file specifying how to build the project using CMake \autocite{cmake}. To build a node with c++, configure the CMakeLists.txt to point to the source code and build the project with catkin.

ROS ships with a tool called catkin for creating the boiler plate code needed for a package, and for building one or many packages at once. Catkin calls in to CMake, and so uses CMakeLists.txt files for building. To use catkin, create a catkin workspace and place each package under a subfolder in the workspace called src. A typical workspace would look like:
#+begin_src bash
  catkin_ws/
      build/ # Subfolders not listed - contains build artifacts
      devel/ # Subfolders not listed - contains the resulting executables and bash scripts after building
      src/
          CMakeLists.txt # symbolic link pointing to /opt/ros/noetic/share/catkin/cmake/toplevel.cmake
          package1/
              CMakeLists.txt
              package.xml
              ...
          ...
          packageN/
              CMakeLists.txt
              package.xml
              ...
#+end_src
The catkin workspace lives on the local machine building the packages only - this wouldn't be committed to source control - the packages would be. Often, when there are multiple interdependent packages, rather than placing each package in its own repository they are grouped in a single repo. In this case, all packages can be cloned directly into the catkin_ws/src folder. To create a workspace:
#+begin_src bash
  $ mkdir -p ~/catkin_ws/src && cd ~/catkin_ws
  $ catkin_make
#+end_src
where catkin_ws can be called anything.

Though nodes can individually be started, often multiple nodes need to be started simultaneously and work together as a group. ROS provides another command line tool, roslaunch, which takes a package name and launch file as parameters. Launch files are special config files which can be added to packages by placing the file/s in a launch subfolder:
#+begin_src bash
  package1/
      CMakeLists.txt
      package.xml
      launch/
          your_launch_file.launch
#+end_src
A launch file allows specifying nodes that should be started when the launch file is called with roslaunch. In the above example, the launch file would be loaded by calling:
#+begin_src bash
  $ roslaunch package1 your_launch_file.launch
#+end_src
As long as the launch file is in the launch subfolder of package1 it will be found.

*** Packages From Source
Most ROS packages are installed using the package manager (apt install ros-noetic-package-name), however some must be built from source. This could be a custom coded package, or a package that was never added to the apt repository.

To build an ROS package with catkin, the package must first be added to the catkin workspace. Without catkin, packages can be built directly with cmake but building with catkin provides setup bash files in the devel (and install if wanted) workspace subfolders. Just as sourcing the main ROS setup script adds ROS commands to the path, sourcing the setup script adds all built targets to the path so they are callable from ROS tools. Assuming a catkin workspace is setup as previously shown and the package is added to the workspace, to build simply use:
#+begin_src bash
  $ catkin_make
  $ catkin_make install # optional
#+end_src
Once the setup.bash script in the devel (or install) subfolder of the workspace is sourced, all ROS commands will work with any of the built packages as if they were installed with the package manager. It makes sense, then, to also add lines to .bashrc file to source any workspaces used for ROS package development.

** Topics, Messages, and Parameters
ROS nodes communicate with eachother through topics and messages. Messages are data schemas - similar to a struct in C or a table in SQL. The basic building block data types can be found in the package std_msgs - but custom messages can be composed by using any other message as members. For example, a couple of important messages in this project:

#+begin_src python
  ## geometry_msgs/Twist
  Vector3  linear
  Vector3  angular

  ## geometry_msgs/Vector3
  float64 x
  float64 y
  float64 z
#+end_src

The Twist message is used to convey driving velocity commands - the linear describes velocity along each axis while the angular describes velocity about each axis. The values don't have any direct relation to units - each robot chooses min/max values and correlates them to driving motor speeds.

Topics are named destinations for certain message types. By sending and receiving messages to/from topics rather than to/from nodes directly, nodes require no direct information about other nodes - they only require the string names and message types of topic of interest. As mentioned earlier, the rosmaster process is in charge of establishing connections between nodes who publish/subscribe to the same topic.

A topic is created by publishing a message to the topic - this can be done in c++ or python code within a node, or using the rostopic pub command. Once a message is published to a topic for the first time, the topic is linked to that message type and ROS logs errors if other message types are published to that topic. The rostopic list command can be used to get a complete list of the current topics:

#+begin_src bash
    $ rostopic list
  /rosout
  /rosout_agg
#+end_src

This message/topic system is the most fundemental thing that makes ROS useful. For example, a vendor can build a LIDAR device any way they want; to make it ROS compatible the vendor would write a node which publishes LaserScan messages to the scan topic. Usually there is a way to configure which topic the message would publish to, in case there are multiple LIDARs or scan is being used for something else. One way to provide a customization point is through parameters.

As part of roscore, ROS starts a parameter server. The server provides an API for nodes to register variables that are customizable and stores these variables and their values as a dictionary. Parameters can be set and retreived via c++ and python API, as well as through the command line tool rosparam. What paremeters do exactly is node dependent, but usually they provide a way to alter the node's behaviour at runtime. The navigation stack, for example, makes use of parameters to configure things like which navigation algorithm should be used, or how often should the pathfinding loop execute. Parameters can also be set for nodes using launch files, but only on node startup.

While nodes can use messages to communicate with eachother, messages tend to be used for active dynamic data while parameters are used for more static node configuration.

** Driving
Both the Jackal and Husky include wireless controllers which directly drive the robots. In each robot there is an ROS node called bluetooth_teleop/joy_node which reads the joystick device file at /dev/js and converts this to a Joy message:

#+begin_src python
    Header header   # timestamp in the header is the time the data is received from the joystick
    float32[] axes  # the axes measurements from a joystick
    int32[] buttons # the buttons measurements from a joystick
#+end_src

The message is posted to the topic /bluetooth_teleop/joy, which another node called /bluetooth_teleop/teleop_twist_joy subscribes to. This node translates the buttons and axis from the controller message to velocity drive commands and posts Twist messages containing these commands to the /bluetooth_teleop/cmd_vel topic.

There is a node called /twist_mux which is responsible for multiplexing the velocity command messages from the controller nodes with velocity commands from other sources. For example, using an ROS tool called rviz \autocite{rviz}, it is possible to drive the Jackal/Husky by dragging drive arrows shown in figure [[fig:jackal_rviz]] with the mouse.

#+caption: Jackal in rviz with driving controls
#+name:   fig:jackal_rviz
#+attr_latex: :width 5in
[[./images/jackal_rviz.png]]
\FloatBarrier

On dragging, RViz sends forward/back/left/right/rotate commands to the node /twist_marker_server which translates these commands to Twist messages and publishes these messages to the /twist_marker_server/cmd_vel topic. The /twist_mux node subscribes to all /cmd_vel topics and produces a single Twist message which is published to /jackal_velocity_controller/cmd_vel. The motor control board (or gazebo if simulating) then directly controls the jackals drive motors based on this message.

#+caption: Node/topic layout - nodes in ovals topics and namespaces in rectangles
#+name:   fig:drive-topics
#+attr_latex: :width 7in
[[./images/rqt_graph.png]]
\FloatBarrier

The link from /twist_mux to /jackal_velocity_controller/cmd_vel is removed for clarity. The easiest way to drive the Jackal and Husky programatically is to publish Twist messages to one of the /cmd_vel topics. This can be done directly using rostopic pub:

#+begin_src bash
$ rostopic pub -r 10 /cmd_vel geometry_msgs/Twist  '{linear:  {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.3}}'
#+end_src

This spins the Husky or Jackal around at 0.3 rads per second. Since the jackal can only drive forward/backward and rotate, y and z do nothing in linear portion of the message and x and y do nothing in the angular portion of the message. Linear x (+/-) is used to drive forward and backward, and to turn left/right angular x (+/-) is used.

** Transform Heirarchy
ROS represents 6 DOF geometric items' positions and orientations as transforms from parent to child coordinate frames. The parent/child relationship of transformations forms a heirarchy where each frame is a node in the world graph - this is identical to a scene graph in rendering libraries. A frame's position and orientation is always releative to it's parent frame, with the root frame having no parent.

Frames can be added to the heirarchy by publishing TFMessage to the /tf or /tf_static topic. The /tf_static topic can be used to publish transforms that don't change - all tf_static transforms are broadcast to subscribers only once when the nodes first subscribe. The format for the message is (all different message types shown in block for convenience):

#+begin_src python
  ## tf2_msgs/TFMessage
  geometry_msgs/TransformStamped[] transforms;

  ## geometry_msgs/TransformStamped
  Header header
  string child_frame_id # the frame id of the child frame
  geometry_msgs/Transform transform

  ## std_msgs/Header
  uint32 seq
  time stamp
  string frame_id

  ## geometry_msgs/Transform
  geometry_msgs/Vector3 translation # This is already shown above
  geometry_msgs/Quaternion rotation

  ## geometry_msgs/Quaternion
  float64 x
  float64 y
  float64 z
  float64 w
#+end_src

The frame_id in the header is the parent frame; the transform is giving the translation and rotation of child_frame_id in relation to frame_id. To work out the orientation and position of child frames in the root coordinate frame (or what some libraries would call "world coordinates"), we start at the root coordinate frame and build a four by four transformation matrix from the root frame orientation and position, which for the root frame is equal to the translation and rotation.

Using row major matrix layout, the transform matrix is created by first creating a rotation matrix from the quaternion orientation as shown in equation (1) \autocite{quatrot} (with x y z and w from the quaternion message above), and using the rotation matrix as the basis for the 4x4 matrix. The 3D position is then set as the last column in the 4x4 matrix, with 1 left as the last element in the column.

\begin{gather}
  Rot_{3x3} = 
  \begin{bmatrix}
    1-2y^{2}-2z^{2} & 2xy+2wz & 2xz-2wy\\
    2xy-2wz & 1-2x^{2}-2z^{2} & 2yz+2wx\\
    2xz+2wy & 2yz-2wx & 1-2x^{2}-2y^{2}
  \end{bmatrix}
\end{gather}

The following C/C++ code creates a 4x4 transformation matrix given the translation vector and rotation quaternion of a frame:

#+begin_src cpp
  struct quaternion
  {
      float x;
      float y;
      float z;
      float w;
  };

  struct vector3
  {
      float x;
      float y;
      float z;
  };

  struct matrix4
  {
      float data[4][4];
  };

  matrix4 create_transform(const quaternion &rotation, const vector3 &translation)
  {
    matrix4 ret {};

    // Build the rotation basis from the passed in rotation quaternion
    ret.data[0][0] = 1 - 2 * (rotation.y * rotation.y + rotation.z * rotation.z);
    ret.data[0][1] = 2 * (rotation.x * rotation.y - rotation.z * rotation.w);
    ret.data[0][2] = 2 * (rotation.x * rotation.z + rotation.y * rotation.w);

    ret.data[1][0] = 2 * (rotation.x * rotation.y + rotation.z * rotation.w);
    ret.data[1][1] = 1 - 2 * (rotation.x * rotation.x + rotation.z * rotation.z);
    ret.data[1][2] = 2 * (rotation.y * rotation.z - rotation.x * rotation.w);

    ret.data[2][0] = 2 * (rotation.x * rotation.z - rotation.y * rotation.w);
    ret.data[2][1] = 2 * (rotation.y * rotation.z + rotation.x * rotation.w);
    ret.data[2][2] = 1 - 2 * (rotation.x * rotation.x + rotation.y * rotation.y);

    // Add the translation vector as the last column
    ret.data[3][0] = translation.x;
    ret.data[3][1] = translation.y;
    ret.data[3][2] = translation.z;

    // Finally leave 1 in the last matrix position (m44) from the identity
    ret.data[3][3] = 1.0f;
    return ret;
  }
#+end_src

With the root node transform ready, we iterate over all child frames and build a transform as we did for the root frame. We then multiply the parent frame by the child frame as shown in equation 2 to get the child frame's world transform - which can be used to determine the child frame position and orientation in the same coordinates as the root frame.

\begin{gather}
  Transform_{world} = Transform_{parent} \times Transform_{child}
\end{gather}

Getting the position from the matrix is easy - its the first three elements of the last column. The derivation for getting the orientation as a quaternion from the matrix is a bit more complicated but is detailed in \autocite{tform_matrix}, along with the coordinate transformation process. The code below shows an example of grabbing it:

#+begin_src cpp
  quaternion orientation(const matrix3 &rotation)
  {
      quaternion ret; 
      float tr = rotation.data[0][0] + rotation.data[1][1] + rotation.data[2][2], s;

      if (tr > 0)
      {
          s = sqrt(tr + 1.0) * 2;
          ret.w = 0.25 * s;
          ret.x = (rotation.data[2][1] - rotation.data[1][2]) / s;
          ret.y = (rotation.data[0][2] - rotation.data[2][0]) / s;
          ret.z = (rotation.data[1][0] - rotation.data[0][1]) / s;
      }
      else if ((rotation.data[0][0] > rotation.data[1][1]) & (rotation.data[0][0] > rotation.data[2][2]))
      {
          s = sqrt(1.0 + rotation.data[0][0] - rotation.data[1][1] - rotation.data[2][2]) * 2;
          ret.w = (rotation.data[2][1] - rotation.data[1][2]) / s;
          ret.x = 0.25 * s;
          ret.y = (rotation.data[0][1] + rotation.data[1][0]) / s;
          ret.z = (rotation.data[0][2] + rotation.data[2][0]) / s;
      }
      else if (rotation.data[1][1] > rotation.data[2][2])
      {
          s = sqrt(1.0 + rotation.data[1][1] - rotation.data[0][0] - rotation.data[2][2]) * 2;
          ret.w = (rotation.data[0][2] - rotation.data[2][0]) / s;
          ret.x = (rotation.data[0][1] + rotation.data[1][0]) / s;
          ret.y = 0.25 * s;
          ret.z = (rotation.data[1][2] + rotation.data[2][1]) / s;
      }
      else
      {
          s = sqrt(1.0 + rotation.data[2][2] - rotation.data[0][0] - rotation.data[1][1]) * 2;
          ret.w = (rotation.data[1][0] - rotation.data[0][1]) / s;
          ret.x = (rotation.data[0][2] + rotation.data[2][0]) / s;
          ret.y = (rotation.data[1][2] + rotation.data[2][1]) / s;
          ret.z = 0.25 * s;
      }
      return ret;
  }
#+end_src

The transform heirarchy is crucial for mapping, localization, and navigation. Even without any simultaneous localization and mapping (SLAM) nodes enabled, the Jackal and Husky use odometry and the IMU information along with the transform heirarchy to produce an estimate as to where it is in the world. The root level frame in this case is called odom. The ekf localization node calculates the base_link rotation/translation (as relative to odom) and publishes the odom frame with the base_link as the child frame as shown in figure [[fig:ekf-localization]].

#+caption: ekf_localization node publishing edits to base_link odom transform frame to /tf based on multiple inputs
#+name:   fig:ekf-localization
#+attr_latex: :width 3in
[[./images/ekf_localization_node.png]]
\FloatBarrier

The complete jackal heirarchy without any SLAM nodes running is shown in figure [[fig:transform-heirarchy]]. The husky is nearly identical - but has a few different leaf nodes for its sensors and geometry. Most of the transform frames are published by the /robot_state_publisher node. This node reads in a URDF file from the parameter server and publishes transforms to /tf based on the contents of the URDF file. URDF is a file format that lists robot joints and links; links correspond to frames, and joints list the parent/child relationships between frames - there are several tutorials here \autocite{urdf}.

#+caption: Transform heirarchy for the jackal
#+name:   fig:transform-heirarchy
#+attr_latex: :width 7in
[[./images/transform.png]]
\FloatBarrier

** SLAM GMapping
Simultaneous Localization and Mapping, or SLAM, refers to the process of reading in sensor data over time, using the changing sensor data to find landmarks and build a map, and then using the landmarks and map to localize the robot. One of the most widely used algorithms to do SLAM with two-dimensional planar LIDAR data is gmapping. The gmapping SLAM algorithm, as proposed in \autocite{gmapping}, is implemented on OpenSLAM \autocite{open_slam_gmapping}, and ported to ROS as a package \autocite{gmapping_package}. The package launches a node called slam_gmapping which subscribes to /front/scan and /tf, performs SLAM using the data on those topics, and publishes the resulting map as an OccupancyGrid to the /map topic as shown in figure [[fig:gmapping_graph]]. 

#+caption: GMapping package node and updated transform tree
#+name:   fig:gmapping_graph
#+attr_latex: :width 6in
[[./images/gmapping_graph.png]]
\FloatBarrier

A new transform frame called map is also published to the /tf topic as shown in figure [[fig:gmapping_graph]]. The slam_gmapping node performs localization by calculating the odom translation/rotation (as relative to the map using gmapping SLAM algorithm) and publishing the map frame to /tf with the odom frame as its child. In the complete picture, ekf_localization updates the relative transform of base_link to odom by using the IMU/odometry, and slam_gmapping updates the relative transform of odom to map by using SLAM based on the LIDAR scan data.

The OccupancyGrid message format is:
#+begin_src python
  ## nav_msgs/OccupancyGrid
  std_msgs/Header header
  nav_msgs/MapMetaData info
  # The map data, in row-major order, starting with (0,0).
  # Occupancy probabilities are in the range [0,100].  Unknown is -1.
  int8[] data

  ## nav_msgs/MapMetaData
  time map_load_time
  # The map resolution [m/cell]
  float32 resolution
  # Map width [cells]
  uint32 width
  # Map height [cells]
  uint32 height
  # The origin of the map [m, m, rad].  This is the real-world pose of the
  # cell (0,0) in the map.
  geometry_msgs/Pose origin

  ## geometry_msgs/Pose
  Point position
  Quaternion orientation

  ## geometry_msgs/Point
  float64 x
  float64 y
  float64 z
#+end_src

This message type is used for costmaps in addition to maps. For maps, the values in data are either 0, 100, or -1; not the full range of [0-100]. With a map available, the navigation stack can run and create costmaps and use those costmaps to create drive paths.

** Navigation Stack
The navigation stack on ROS refers to the move_base node, the plugins the move_base node uses, and all the topics published by move_base. Figure [[fig:nav_stack]] shows an overview of the node/topic relationship \autocite{nav_stack}. The move_base node is configurable; the ovals inside of the move_base rectangle indicate parts of the node which run using plugins - this means the user can create a shared library and, with some configuration, move_base will use the shared library in place of the default behaviour.

#+caption: Navigation stack overview
#+name:   fig:nav_stack
#+attr_latex: :width 6in
[[./images/overview_tf_small.png]]
\FloatBarrier

The move_base node only issues velocity commands to the robot if there is an active navigation path, and there is only an active navigation path if the global planner has received a PoseStamped goal message on topics move_base/goal or move_base_simple/goal. The PoseStamped message is the Pose message with a Header added. The move_base node will start trying to drive the robot to the target pose once a PoseStamped message is received on either topic. Move_base publishes goal status' to the move_base/status topic in the form of an array of GoalStatus messages:

#+begin_src python
  ## actionlib_msgs/GoalStatusArray
  std_msgs/Header header
  actionlib_msgs/GoalStatus[] status_list

  ## actionlib_msgs/GoalStatus
  actionlib_msgs/GoalID goal_id
  string text    
  # 0 (PENDING) The goal has yet to be processed by the action server
  # 1 (ACTIVE) The goal is currently being processed by the action server
  # 2 (PREEMPTED) The goal received a cancel request after it started executing
  #   and has since completed its execution (Terminal State)
  # 3 (SUCCEEDED) The goal was achieved successfully by the action server (Terminal State)
  # 4 (ABORTED) The goal was aborted during execution by the action server due
  #   to some failure (Terminal State)
  # 5 (REJECTED) The goal was rejected by the action server without being processed,
  #   because the goal was unattainable or invalid (Terminal State)
  # 6 (PREEMPTING) The goal received a cancel request after it started executing
  #   and has not yet completed execution
  # 7 (RECALLING) The goal received a cancel request before it started executing,
  #   but the action server has not yet confirmed that the goal is canceled
  # 8 (RECALLED) The goal received a cancel request before it started executing
  #   and was successfully cancelled (Terminal State)
  # 9 (LOST) An action client can determine that a goal is LOST. This should not be
  #   sent over the wire by an action server
  uint8 status

  ## actionlib_msgs/GoalID
  time stamp
  string id
#+end_src

The Jackal and Husky move_base implementations only work on a single goal at a time, but if a goal is cancelled and another goal issued quickly, multiple goals can appear in the status array. To get the correct goal in all cases, the goal id associated with the original goal pose as in the PoseStamped message is needed. On receiving a goal, move_base will publish a MoveBaseActionGoal message to the topic /move_base/goal which gives the pose and id of the goal:

#+begin_src python
  ## move_base_msgs/MoveBaseActionGoal
  Header header
  actionlib_msgs/GoalID goal_id
  MoveBaseGoal goal

  ## move_base_msgs/MoveBaseGoal
  geometry_msgs/PoseStamped target_pose

  ## geometry_msgs/PoseStamped
  std_msgs/Header header
  geometry_msgs/Pose pose
#+end_src

Since the MoveBaseActionGoal message contains the goal id as generated by move_base for the pose published by the user to move_base_simple/goal, the user can store the goal id and use it to parse the goal status updates. To build a navigation path to reach the goal, move_base builds two costmaps; a local and global costmap. The global costmap sources the global planner, and the local costmap sources the local planner.

*** Costmaps
Both the local and the global costmaps contain data about nearby obstacles - the difference between the costmaps is in the configuration. The global costmap is usually configured to use map as its global frame, be the same size as the OccupancyGrid published to the /map topic, and to not move along with the robot. The local costmap uses odom as its global frame, is much smaller than the global costmap, and stays centered over the robot as the robot moves around.

By default, the Jackal and Husky do not start with any navigation stack nodes running. On ROS Noetic, there is a package for the Jackal called jackal_navigation and for the Husky called husky_navigation which start all /move_base nodes to build a navigation stack. 

*** Local Planner
The local planner uses odometry and the local costmap to try and direct the robot along the path dictated by the global planner. It  

** Simulation
Text

* Clearpath Robot Configuration
Text

** Upgrade ROS from ROS Indigo to ROS Noetic
Text

** Configure sensor nodes to run at startup
Text

** Configure Bumblebee Camera (Jackal Only)
Text

** Configure network using Netplan
Text

** Configure Bluetooth PS4 Controllers (upgraded for Jackal)
Text

** Fix Husky E-Stop malfunction
Text

* Wifi Network
Text

** Network Overview
Text

** Restore Base Stations
Text

** Router Firmware Upgrade
Text

** Router Configuration
Text

** Custom DNS Servers
Text

* Client Server App
The client app is written in c/c++ and uses emscripten to cross compile to WebAssembly.

** Setup and Build
To build the client app, cmake is required along with tools sourced from build-essentials linux package.

*** Emscripten
Text

*** Urho3D
Text

*** UGV Control
Text

*** UGV Server
Text

** Feature/Interface Overview
Using a

** Observer and Controller
Text

** Scene
Text
*** Urho3D Rendering
Text

*** Transform Tree
Text

*** Jackal/Husky Models
Text

*** Camera
Text

** UI
Text
*** Creating Icons with Inkscape
Text

*** UI File and Anchoring
Text

*** Input
Text

*** Scaling for different pixel ratios
Text

*** Toolbar
Text

*** Console
Text

*** View Toggle Panel
Text

** Networking
Text
*** Packing and Unpacking Data
Text

*** Packet Structure and Header
Text

*** Client/Server Routing with Sockets and WebSockets
Text

*** Sending/Receiving Data
Text

*** Bandwidth
Text

** Server ROS Interface with rosnodejs
Text

** Joystick Driving
Text

** Map Building
Text

** Autonomous Waypoint Navigation
Text

** Getting and Setting ROS Parameters
Text

** Live Camera Feed (Jackal Only)
Text

** Misc
Text

*** Connection tracking
Text

*** Measuring paths
Text

*** Broadcast messages
Text

* Conclusion
Text

** Project Summary
Text

** Lessons Learned
Text

** Future Work
Text

** Final Remarks
Text

\newpage

\printbibliography
